library(lsei)
source("cnm.R")


## using the example in Yong's website
mix.efron <- normmix(mu = c(-10.9, -7, -4.9, -1.9, -1.1, 0, 2.4, 6.1),
                     pi = c(1.5, 1.3, 5.6, 12.3, 13.6, 60.9, 2.7, 2.2))
set.seed(1)

x <- rnormmix(n = 1000, mix = mix.efron)
fit <- cnm.normmix(x, tol = 1e-5)
abline(v = fit$mix$mu, col ="red")


thai <- data.frame(x=c(0:21, 23, 24),
                   freq=c(120, 64, 69, 72, 54, 35, 36, 25, 25, 19, 18,
                   18, 13, 4, 3, 6, 6, 5, 1, 3, 1, 2, 1, 2))
cnm.poismix(x=thai$x, w=thai$freq)



x <- rnorm(100)
y <- 2 + x + c(rnorm(100, 0, rep(c(2, 10), 50)))

cnm.normmix(y - x, tol = 1e-5)

## Normmix only works for different mean.
y <- c(rnorm(100, rep(c(8, 10), 50)), 1)
cnm.normmix(y)

myll <- function(x, a, b) dnorm(b - x * a)


myll <- function(x, a, b) sum(dnorm(b - x * a))
optimize(myll, c(0, 1), a = x, b = y)


## This is the usual maximum likelihood estimation
x <- rnorm(100)
y <- 2 + 0.8 * x + rnorm(100)

myll <- function(beta){
    -sum(dnorm(y - beta[1] - beta[2] * x))
}

test.mle <- optim(c(1, 1), myll)
test.mle
plot(x, y)
abline(test.mle$par[1], test.mle$par[2], col = "red")
test.lm <- lm(y ~ x)
abline(coef(test.lm)[1], coef(test.lm)[2], col = "blue")
test.glm <- lm(y ~ x)
abline(coef(test.glm)[1], coef(test.glm)[2], col = "green")


x1 <- rnorm(100)
x2 <- rnorm(100)
y <- 1 + 2 * x1 + 3 * x2 + rnorm(100)

## Extended to 2 variable
myll2 <- function(beta){
    -sum(dnorm(y - beta[1] - beta[2] * x1 - beta[3] * x2))
}
optim(c(0, 0, 0), myll2)

t3d.df <- data.frame(y, x1, x2)
library(boot)
myll3 <- function(data){
    ll <- -sum(dnorm(data[, 1] - beta[1] - beta[2] *
               data[, 2] - beta[3] * data[, 3]))
    optim(c(0, 0, 0), ll)$par
}

myll3 <- function(data){
    ll <- function(beta)
        -sum(dnorm(data[, 1] - beta[1] - beta[2] *
                     data[, 2] - beta[3] * data[, 3]))
    optim(c(0, 0, 0), ll)$par
}


boot(t3d.df, myll3, R = 1000)
