######################################################################
## This script attempts to include skewness and mean in the
## estimation.
######################################################################


logd.mgarch <- function(xt, beta, pt, which){
    xt <- as.numeric(xt)
    xt2 <- xt^2
    T <- length(xt)
    pt2 <- pt^2
    lpt <- length(lp)
    lb <- length(beta)
    dl <- vector("list", length = 4)
    names(dl) <- c("ld", "db1", "dt1", "dt2")
    sigmat2 <- double(T)
    sigmat2[1] <- var(xt) ## Initialise as the variance of the data
    for(i in 2:T){
        sigmat2[i] <- beta[1] + beta[2] * sigmat2[i - 1] +
            beta[3] * xt2[i - 1]
    }
    sigma.t <- sqrt(sigmat2)
    if(which[1] == 1){
        dl$ld <- matrix(-(0.5 * log(2 * pi) + log(sigma.t) +
                          rep(log(pt), each = T) +
                          ((xt - beta[4])^2/sigmat2)/
                          rep(2 * pt2, each = T)), nr = T, nc = lpt)
    }
    if(which[1] == 2){
        dldsigma <- matrix(xt2/sigma.t^3 /rep(pt2, each = T) -
                           1/sigma.t, nr = T, nc = lpt)
        sig.vec <- 2 * sigma.t
        cp.alpha <- cumsum(c(0, beta[2]^(0:(T-2))))
        cp.beta <- double(T)
        cp.beta[1:2] <- 0
        for(i in 3:T){
            cp.beta[i] <- beta[3] * sum((1:(i - 2)) *
                                        beta[2]^(0:(i - 3)) *
                                        rev(xt2[1:(i - 2)]))
        }

        dsigmadalpha0 <- cp.alpha #1

        dsigmadalpha1 <-
            (beta[1] *
             cumsum(c(0, 0, 1:(T - 2) * beta[2]^(0:(T - 3))))) +
                 c(0, 1:(T - 1) * beta[2]^(0:(T - 2)) * beta[4]^2) +
                     cp.beta #2

        cp.beta2 <- double(T)
        cp.beta2[1] <- 0
        for(i in 2:T){
            cp.beta2[i] <- sum(beta[2]^(0:(i - 2)) *
                              rev(xt2[1:(i - 1)]))
        }
        dsigmadbeta1 <- cp.beta2 #3
        dsigmadmu <- (xt - beta[4])/sigmat2 * 1/rep(pt, each = T)

        dbvec <- array(c(rep(dsigmadalpha0, lpt),
                         rep(dsigmadalpha1, lpt),
                         rep(dsigmadbeta1, lpt),
                         rep(dsigmadmu, lpt))
                       dim = c(T, lpt, lb))

        dldsigma <- array(dldsigma/sig.vec, dim = c(T, lpt, lb))
        dl$db1 <- dldsigma * dbvec
    }
    if(which[1] == 3){
      dt1 = xt2/sigmat2 / rep(pt^3, each=T) - 1/rep(pt, each=T)
      dim(dt1) = c(T,lpt)
      dl$dt1 = dt1
    }
    if(which[1] == 4){
        dt2 <- (-3 * xt2)/sigmat2 /rep(pt^4, each = T) +
            1/(rep(pt2, each = T))
        dim(dt2) = c(T, lpt)
        dl$dt2 = dt2
    }
    dl
}

# Byte compile the function
logd.mgarch <- cmpfun(logd.mgarch)


valid.mgarch <- function(x, beta, mix){
    beta[1] > 0 &&
    beta[2] >= 0 &&
    beta[3] >= 0 &&
#    (beta[2] + beta[3] < 1)
}

valid.snpmle <- function(x, beta, mix)
  valid(x, beta, mix) && all(mix$pr >= 0)


initial.mgarch <- function(x, beta = NULL, mix = NULL, kmax = NULL){
    if(is.null(beta)){
        cgf <- coef(garchFit(data = as.numeric(x), trace = FALSE))
        beta <- c(cgf[2], cgf[4], cgf[3], cgf[1])
        mix <- dden(1, 1)
        list(beta = beta, mix = mix)
    }
}



