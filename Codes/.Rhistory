      J=INDEX(IZ)   
!
!   Set FREE1 = true if X(J) is not at the left end-point of its 
!   constraint region.
!   Set FREE2 = true if X(J) is not at the right end-point of its 
!   constraint region.
!   Set FREE = true if X(J) is not at either end-point of its 
!   constraint region.
!
     FREE1 = X(J)   >   BND(1,J) 
     FREE2 = X(J)   <   BND(2,J) 
     FREE = FREE1 .and. FREE2  

     IF  ( FREE ) then   
        CALL TEST_COEF_J_FOR_DIAG!_ELT_AND_DIRECTION_OF_CHANGE
     else
!   Compute dual coefficient W(J).   
           W(J)=dot_product(A(NPP1:M,J),B(NPP1:M))  
!
!   Can X(J) move in the direction indicated by the sign of W(J)?
!
          IF  ( W(J)   <  ZERO ) then  
             IF  ( FREE1 ) &
                CALL TEST_COEF_J_FOR_DIAG!_ELT_AND_DIRECTION_OF_CHANGE
          ELSE  IF  ( W(J)   >  ZERO ) then
             IF  ( FREE2 ) &
                CALL TEST_COEF_J_FOR_DIAG!_ELT_AND_DIRECTION_OF_CHANGE
          END IF
       END IF
       IF  ( FIND ) RETURN
   END DO!  IZ  
END SUBROUTINE! ( SELECT ANOTHER COEF TO SOLVE FOR ) 

SUBROUTINE TEST_COEF_J_FOR_DIAG!_ELT_AND_DIRECTION_OF_CHANGE
!
!   The sign of W(J) is OK for J to be moved to set P.
!   Begin the transformation and check new diagonal element to avoid
!   near linear dependence.   
!   
   ASAVE=A(NPP1,J)   
   call HTC (NPP1, A(1:M,J), UP)
   UNORM = NRM2(A(1:NSETP,J))
   IF  ( abs(A(NPP1,J)) > EPS * UNORM) then
!
!   Column J is sufficiently independent.  Copy b into Z, update Z.
      Z(1:M)=B(1:M)
! Compute product of transormation and updated right-hand side.
      NORM=A(NPP1,J); A(NPP1,J)=UP
      IF(ABS(NORM) > ZERO) THEN
         SM=DOT_PRODUCT(A(NPP1:M,J)/NORM, Z(NPP1:M))/UP
         Z(NPP1:M)=Z(NPP1:M)+SM*A(NPP1:M,J)
         A(NPP1,J)=NORM
      END IF

      IF  (abs(X(J)) >  ZERO) Z(1:NPP1)=Z(1:NPP1)+A(1:NPP1,J)*X(J)
!   Adjust Z() as though X(J) had been reset to zero. 
      IF  ( FREE ) then   
         FIND = .TRUE.  
      else  
!
!   Solve for ZTEST ( proposed new value for X(J) ).
!   Then set FIND to indicate if ZTEST has moved away from X(J) in
!   the expected direction indicated by the sign of W(J).
         ZTEST=Z(NPP1)/A(NPP1,J)
         FIND = ( W(J)  <  ZERO  .and.  ZTEST   <  X(J) )  .or. & 
         ( W(J)  >  ZERO  .and.  ZTEST  >  X(J) )
      END IF
   END IF
!
!   If J was not accepted to be moved from set Z to set P,
!   restore A(NNP1,J).  Failing these tests may mean the computed 
!   sign of W(J) is suspect, so here we set W(J) = 0.  This will  
!   not affect subsequent computation, but cleans up the W() array.
   IF  ( .not. FIND ) then 
      A(NPP1,J)=ASAVE
      W(J)=ZERO 
   END IF! ( .not. FIND )
END SUBROUTINE !TEST_COEF_J_FOR_DIAG!_ELT_AND_DIRECTION_OF_CHANGE

SUBROUTINE MOVE_J_FROM_SET_Z_TO_SET_P
!
!   The index  J=index(IZ)  has been selected to be moved from
!   set Z to set P.  Z() contains the old B() adjusted as though X(J) = 0.  
!   A(*,J) contains the new Householder transformation vector.    
   B(1:M)=Z(1:M)
!
   INDEX(IZ)=INDEX(IZ1)  
   INDEX(IZ1)=J  
   IZ1=IZ1+1 
   NSETP=NPP1
   NPP1=NPP1+1   
!   The following loop can be null or not required.
   NORM=A(NSETP,J); A(NSETP,J)=UP
   IF(ABS(NORM) > ZERO) THEN
      DO JZ=IZ1,IZ2 
         JJ=INDEX(JZ)
         SM=DOT_PRODUCT(A(NSETP:M,J)/NORM, A(NSETP:M,JJ))/UP
         A(NSETP:M,JJ)=A(NSETP:M,JJ)+SM*A(NSETP:M,J)
      END DO
   A(NSETP,J)=NORM
   END IF
!   The following loop can be null.
   DO L=NPP1,M   
      A(L,J)=ZERO
   END DO!  L
!
   W(J)=ZERO 
!
!   Solve the triangular system.  Store this solution temporarily in Z().
   DO I = NSETP, 1, -1
      IF  (I  /=  NSETP) Z(1:I)=Z(1:I)-A(1:I,II)*Z(I+1)
      II=INDEX(I)   
      Z(I)=Z(I)/A(I,II) 
   END DO 
END SUBROUTINE! ( MOVE J FROM SET Z TO SET P )  

SUBROUTINE TEST_SET_P_AGAINST_CONSTRAINTS 
!
   LOOPB: DO
!   The solution obtained by solving the current set P is in the array Z().
!
      ITER=ITER+1   
      IF  (ITER   >  ITMAX) then 
         IERR = 4   
         exit LOOPB   
      END IF
!
      CALL SEE_IF_ALL_CONSTRAINED_COEFFS!_ARE_FEASIBLE
!
!   The above call sets HITBND.  If HITBND = true then it also sets 
!   ALPHA, JJ, and IBOUND.  
     IF  ( .not. HITBND ) exit LOOPB   
!
!   Here ALPHA will be between 0 and 1 for interpolation  
!   between the old X() and the new Z().
      DO IP=1,NSETP 
         L=INDEX(IP)
         X(L)=X(L)+ALPHA*(Z(IP)-X(L))   
      END DO
!
      I=INDEX(JJ)   
!   Note:  The exit test is done at the end of the loop, so the loop 
!   will always be executed at least once.
      DO
!   
!   Modify A(*,*), B(*) and the index arrays to move coefficient I
!   from set P to set Z.   
!
         CALL  MOVE_COEF_I_FROM_SET_P_TO_SET_Z
!
         IF  (NSETP  <=  0) exit LOOPB  
!
!   See if the remaining coefficients in set P are feasible.  They should
!   be because of the way ALPHA was determined.  If any are infeasible 
!   it is due to round-off error.  Any that are infeasible or on a boundary 
!   will be set to the boundary value and moved from set P to set Z.
!
           IBOUND = 0
           DO JJ=1,NSETP 
              I=INDEX(JJ)
              IF  ( X(I)  <=  BND(1,I)) then 
                  IBOUND=1
                  EXIT
              ELSE IF ( X(I)  >=  BND(2,I)) then
                  IBOUND=2
                  EXIT
              END IF
            END DO
            IF  (IBOUND   <=   0)   EXIT
      END DO
!
!   Copy B( ) into Z( ).  Then solve again and loop back. 
      Z(1:M)=B(1:M)
!   
      DO I = NSETP, 1, -1
         IF  (I  /=  NSETP) Z(1:I)=Z(1:I)-A(1:I,II)*Z(I+1)
         II=INDEX(I)
         Z(I)=Z(I)/A(I,II)  
      END DO
   END DO LOOPB

!   The following loop can be null.
   DO IP=1,NSETP 
      I=INDEX(IP)
      X(I)=Z(IP) 
   END DO

END SUBROUTINE! ( TEST SET P AGAINST CONSTRAINTS)

SUBROUTINE  SEE_IF_ALL_CONSTRAINED_COEFFS!_ARE_FEASIBLE
!
!   See if each coefficient in set P is strictly interior to its constraint region.
!   If so, set HITBND = false.
!   If not, set HITBND = true, and also set ALPHA, JJ, and IBOUND.
!   Then ALPHA will satisfy  0.  < ALPHA  <=  1.
!
   ALPHA=TWO 
   DO IP=1,NSETP
      L=INDEX(IP)   
      IF  (Z(IP)  <=  BND(1,L)) then
!   Z(IP) HITS LOWER BOUND 
         LBOUND=1   
      ELSE  IF  (Z(IP)  >=  BND(2,L)) then
!   Z(IP) HITS UPPER BOUND 
         LBOUND=2   
      else  
         LBOUND = 0 
      END IF
!
      IF  ( LBOUND   /=   0 ) then  
         T=(BND(LBOUND,L)-X(L))/(Z(IP)-X(L)) 
         IF  (ALPHA   >  T) then
           ALPHA=T  
           JJ=IP
           IBOUND=LBOUND
         END IF! ( LBOUND )  
      END IF! ( ALPHA   >  T )   
   END DO 
HITBND = abs(ALPHA   -  TWO) > ZERO  
END SUBROUTINE!( SEE IF ALL CONSTRAINED COEFFS ARE FEASIBLE )

SUBROUTINE MOVE_COEF_I_FROM_SET_P_TO_SET_Z
!   
   X(I)=BND(IBOUND,I)
   IF  (abs(X(I))   >  ZERO .and.  JJ > 0) B(1:JJ)=B(1:JJ)-A(1:JJ,I)*X(I)

!   The following loop can be null.
   DO J = JJ+1, NSETP 
      II=INDEX(J)
      INDEX(J-1)=II  
      call ROTG (A(J-1,II),A(J,II),CC,SS)
      SM=A(J-1,II)
!
!   The plane rotation is applied to two rows of A and the right-hand
!   side.  One row is moved to the scratch array S and then the updates
!   are computed.  The intent is for array operations to be performed 
!   and minimal extra data movement.  One extra rotation is applied 
!   to column II in this approach. 
      S=A(J-1,1:N); A(J-1,1:N)=CC*S+SS*A(J,1:N); A(J,1:N)=CC*A(J,1:N)-SS*S
      A(J-1,II)=SM; A(J,II)=ZERO
      SM=B(J-1); B(J-1)=CC*SM+SS*B(J); B(J)=CC*B(J)-SS*SM
   END DO
!
   NPP1=NSETP
   NSETP=NSETP-1 
   IZ1=IZ1-1 
   INDEX(IZ1)=I  
END SUBROUTINE! ( MOVE COEF I FROM SET P TO SET Z ) 

SUBROUTINE TERMINATION
!
   IF  (IERR   <=   0) then  
!
!   Compute the norm of the residual vector.
      SM=ZERO   
      IF  (NPP1   <=   M) then 
         SM=NRM2(B(NPP1:M))
      else  
         W(1:N)=ZERO
      END IF
      RNORM=SM
   END IF! ( IERR...) 
END SUBROUTINE! ( TERMINATION ) 

SUBROUTINE ROTG(SA,SB,C,S)
!
   REAL(KIND(ONE)) SA,SB,C,S,ROE,SCALE,R 
!
   ROE = SB
   IF( ABS(SA) .GT. ABS(SB) ) ROE = SA
   SCALE = ABS(SA) + ABS(SB)
   IF( SCALE .LE. ZERO ) THEN
      C = ONE
      S = ZERO
      RETURN
  END IF
   R = SCALE*SQRT((SA/SCALE)**2 + (SB/SCALE)**2)
   IF(ROE < ZERO)R=-R
   C = SA/R
   S = SB/R
   SA = R
   RETURN
END SUBROUTINE !ROTG

REAL(KIND(ONE)) FUNCTION NRM2 (X)
!
!   NRM2 returns the Euclidean norm of a vector via the function
!   name, so that
!
!   NRM2 := sqrt( x'*x )
!
   REAL(KIND(ONE)) ABSXI, X(:), NORM, SCALE, SSQ
   INTEGER N, IX
   N=SIZE(X)
   IF( N < 1)THEN
      NORM  = ZERO
   ELSE IF( N == 1 )THEN
      NORM  = ABS( X( 1 ) )
   ELSE
      SCALE = ZERO
      SSQ   = ONE
!
      DO IX = 1, N
         ABSXI = ABS( X( IX ) )
          IF(ABSXI > ZERO )THEN
             IF( SCALE < ABSXI )THEN
                SSQ   = ONE + SSQ*( SCALE/ABSXI )**2
                SCALE = ABSXI
             ELSE
                SSQ   = SSQ + ( ABSXI/SCALE )**2
             END IF
         END IF
     END DO
     NORM  = SCALE * SQRT( SSQ )
   END IF
!
   NRM2 = NORM
   RETURN
END FUNCTION

SUBROUTINE HTC (P, U, UP)
!
!   Construct a Householder transormation.
   INTEGER P
   REAL(KIND(ONE)) U(:)
   REAL UP, VNORM
   VNORM=NRM2(U(P:SIZE(U)))
   IF(U(P) > ZERO) VNORM=-VNORM
   UP=U(P)-VNORM
   U(P)=VNORM
END SUBROUTINE ! HTC

END SUBROUTINE ! BVLS

      program PROG7
!
!  DEMONSTRATE THE USE OF THE SUBROUTINE BVLS  FOR LEAST   
!  SQUARES SOLVING WITH BOUNDS ON THE VARIABLES.
!   
!  The original version of this code was developed by
!  Charles L. Lawson and Richard J. Hanson and published in the book
!  "SOLVING LEAST SQUARES PROBLEMS." REVISED APRIL, 1995 to accompany 
!  reprinting of the book by SIAM.

IMPLICIT NONE

INTERFACE

  SUBROUTINE BVLS (A, B, BND, X, RNORM, NSETP, W, INDEX, IERR)
    REAL(KIND(1E0)) A(:,:), B(:), BND(:,:), X(:), RNORM, W(:)
    INTEGER NSETP, INDEX(:), IERR
  END SUBROUTINE

END INTERFACE

!     Test driver for BVLS.  Bounded Variables Least Squares.
!     C.L.Lawson, & R.J.Hanson, Jet Propulsion Laboratory, 1973 June 12
!     Changes made in September 1982, June 1986, October 1987.
!     Conversion made to Fortran 90 by R. J. Hanson, April 1995.
!     ------------------------------------------------------------------
!     Subprograms referenced: RANDOM_NUMBER, BVLS 
!     ------------------------------------------------------------------
	
      integer, parameter :: MM=10, NN=10, MXCASE = 6, JSTEP=5
      INTEGER I, J, ICASE, IERR, m, n, nsetp, j1, j2
      integer     MTAB(MXCASE), NTAB(MXCASE)
      real(kind(1E0))   UNBTAB(MXCASE), BNDTAB(2,NN,MXCASE)
      real(kind(1E0))   A(MM,NN),B(MM),X(NN),W(NN)
      real(kind(1E0))   A2(MM,NN),B2(MM), R(MM), D(NN),BND(2,NN)  
      real(kind(1E0)) RNORM, RNORM2, UNBND
     
      integer     INDEX(NN) 
      data MTAB  / 2, 2, 4,  5, 10, 6 /
      data NTAB  / 2, 4, 2, 10,  5, 4 /
      data UNBTAB / 5 * 1.0E6,  999.0E0 /
      data ((BNDTAB(I,J,1),I=1,2),J=1,2)/ 1.,2.,    3.,4.  /
      data ((BNDTAB(I,J,2),I=1,2),J=1,4)/ 0,10,  0,10,  0,10,  0,10/
      data ((BNDTAB(I,J,3),I=1,2),J=1,2)/ 0,100,   -100,100/
      data ((BNDTAB(I,J,4),I=1,2),J=1,10)/&
             0,0,   -.3994E0,-.3994E0,  -1,1,     -.3E0,-.2E0,    21,22,&
                    -4,-3,  45,46,          100,101,  1.E6,1.E6,  -1,1/
      data ((BNDTAB(I,J,5),I=1,2),J=1,5)/&
                     0,1,  -1,0,  0,1,  .3E0,.4E0,  .048E0,.049E0/
      data ((BNDTAB(I,J,6),I=1,2),J=1,4)/&
               -100.,100.,  999.,999.,   999.,999.,   999.,999. /
!     ------------------------------------------------------------------
      write(*,1002)
      DO ICASE = 1,MXCASE
      M = MTAB(ICASE)
      N = NTAB(ICASE)
      UNBND = UNBTAB(ICASE)
      DO J = 1,N
         BND(1,J) = BNDTAB(1,J,ICASE)
         BND(2,J) = BNDTAB(2,J,ICASE)
      END DO
	where(bnd(1,1:N) == UNBND) bnd(1,1:n)=-huge(1e0)
	where(bnd(2,1:N) == UNBND) bnd(2,1:n)= huge(1e0)

      write(*,'(1x/////1x,a,i3/1x)') 'Case No.',ICASE
      write(*,'(1x,a,i5,a,i5,a,g17.5)')&
             'M =',M,',   N =',N,',   UNBND =',UNBND
      write(*,'(1X/'' Bounds ='')')
      DO J1 = 1, N, JSTEP
         J2 = MIN(J1 - 1 + JSTEP, N)
         write(*,*) ' '
         write(*,1001) (BND(1,J),J=J1,J2)
         write(*,1001) (BND(2,J),J=J1,J2)
      END DO
      call random_number (b(1:m))
       DO J=1,N 
          call random_number (A(1:M,J))
      END DO

      write(*,'(1X/'' A(,) ='')')
      DO J1 = 1, N, JSTEP
         J2 = MIN(J1 - 1 + JSTEP, N)
         write(*,*) ' '
         DO I = 1,M
            write(*,1001) (A(I,J),J=J1,J2)
         END DO
      END DO
!   
      B2(1:M)=B(1:M)
      A2(1:M,1:N)=A(1:M,1:N)

      write(*,'(1X/'' B() =''/1X)')
      write(*,1001) (B(I),I=1,M)
!
      call BVLS  (A2(1:M,1:N), B2,BND,X,RNORM,NSETP,W,INDEX, IERR) 
!
       IF(IERR > 0) THEN
           WRITE(*,'(1X, "ABNORMAL ERROR FLAG, IERR = ")') IERR
            STOP
       END IF
      write(*,'(1x/1x,a,i4)') &
        'After BVLS:  No. of components not at constraints =',NSETP
      write(*,'(1X/'' Solution vector, X() =''/1X)')
      write(*,1001) (X(J),J=1,N)

      R(1:M)=B(1:M)-matmul(A(1:M,1:N),X(1:N))
!
      RNORM2=sqrt(dot_product(R(1:M),R(1:M)))
!  
      D(1:N)=matmul(R(1:M),A(1:M,1:N))
      write(*,'(1X/'' R = B - A*X Computed by the driver:''/1X)')
      write(*,1001) (R(I),I=1,M)
      write(*,'(1x,a,g17.5)') 'RNORM2 computed by the driver =',RNORM2
      write(*,'(1x,a,g17.5)') 'RNORM computed by BVLS       = ',RNORM
!
      write(*,'(1X/'' W = (A**T)*R Computed by the driver:''/1X)')
      write(*,1001) (D(J),J=1,N)
      write(*,'(1X/'' Dual vector from BVLS, W() =''/1X)')
      write(*,1001) (W(J),J=1,N)
!   
      END DO ! ICASE
!   
    
 1001 FORMAT(1X,5G14.5)
 1002 FORMAT(&
       ' TESTBVLS.. Test driver for BVLS,',&
       ' Bounded Variables Least Squares.'&
       /'          If the algorithm succeeds the solution vector, X(),'/&
       '           and the dual vector, W(),'/&
       '           should be related as follows:'/&
       '        X(i) not at a bound       =>  W(i) = 0'/&
       '        X(i) at its lower bound  =>  W(i) .le. 0'/&
       '        X(i) at its upper bound  =>  W(i) .ge. 0'/&
       ' except that if an upper bound and lower bound are equal then'/&
       ' the corresponding X(i) must take that value and W(i) may have'/&
       ' any value.'/1X)

      end program PROG7


ls()
AI
AJ
ALPHA
rm(list = ls())
ls()
nnls
library(nnls)
nnls
nnls
rm(list = ls())
ls()
nnls
rm(nnls)
rm(nnls, pos = 1)
rm(nnls, pos = 2)
ls
nnls
source("myTrial.R")
()
ls()
dir()
ls()
source("cnm.R")
library(lsei)
erf
